{"pages":[{"title":"关于","text":"你好，我是碧野，一名 前端 / Python 开发者。 mail: biye#biye.pro 版权申明：若没有特殊说明，文章皆是碧野原创，未经明确许可请勿转载。","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"交易流程","text":"你好，我是碧野，一名 前端 / Python 开发者。 mail: biye#biye.pro 版权申明：若没有特殊说明，文章皆是碧野原创，未经明确许可请勿转载。","link":"/payment/index.html"}],"posts":[{"title":"程序代做业务介绍","text":"关于我们成员来自知名互联网公司和985高校以及中科院，根据需求可24-48小时加急完成。 付款流程：预付50%定金，全部做完后，发程序视频跟客户确认，无误后收取尾款，发送整个程序。（对于难度较大，时间较长的课题，中途可提供部分功能用于老师检查。） 代写特色 ：靠谱售后服务，包括环境配置、程序调试、程序讲解，再不加功能的基础上，进行程序修改。杜绝一手交钱一手交货然后跑路的黑心代写行为，给予客户最大的信任(信任是相互的)，毕业pro代写始终坚持诚信。 温馨提示：目前收到客户反馈的一些黑代写的行为: 骗完定金拉黑，以次充好骗余款, gif演示成功付完钱本地运行不了，弃之不顾…请大家擦亮眼睛 业务范围提供专属的CS程序代写服务，代写各类程序语言，承接各类程序代做作业，java，python，php，c++，网页web，javascript，机器学习，数据挖掘，数据分析，excel，bi，人工智能，数学题，高数，线代，算法题，ui设计，交互设计，英文翻译，论文辅导写作等等。 我们不是中介，我们是团队作业！我们不是代码的搬运工，我们每一分作业均属原创！相比于中介高昂的中介费和个人代写的不靠谱和漫天要价, 我们团队保证质量的同时, 尽量把价格做到最低, 实现同学们和团队工程师的双赢。 我们的优势 我们有经验丰富学历强大的IT一线工程师，成员来自知名互联网公司和985高校以及中科院，最快24-48小时即可完成，用技术和耐心帮助客户高效高质量提交作业。 我们价格公道，绝无高昂的中介费，都是团队自身成员直接接单。 我们可以在30分钟内准确高效的评估作业时间和难度，期中提供答疑服务，完成后可根据需求更改。 无限期售后服务，真正的一站式无忧服务。 郑重承诺【原创】代码保证原创，查重轻松过。 【高质量】是我们坚守的原则, 我们用把精力和时间花在您的作业上，而不是跟您的讨价还价上。 【诚信】在截止日期内，按照您的需求文档保质保量的完成。 【口碑】很多客户长期合作的优质代写团队。 【互相】50%的预付款，完成所有作业，验收后，再结尾款。 【承诺】代码本地run不了，全额退款。因为专业，所以自信。 【售后】所有代写服务均包括配置环境，代码调试、修改、讲解。 联系我们Email: kefu2@biye.pro 微信号: chenqiqicat QQ号: 2422447293 为了保证我们尽快联系和评估您的作业, 请注明您的作业具体要求、时间和年级。 交易流程微信联系我们——工程师看题报价——协定作业价格，支付50%定金——客户中期可了解进度——客户验收，补齐尾款——终身售后。 报价参考：我们根据工作量、难度和时间决定价格，坚决抵制黑中介漫天要价的恶劣行为。 但是也不要低估码农们的劳动成果，毕竟一分钱一分货，you get what you pay for. 客户评价","link":"/front-end/%E7%A8%8B%E5%BA%8F%E4%BB%A3%E5%81%9A%E4%B8%9A%E5%8A%A1%E4%BB%8B%E7%BB%8D/"},{"title":"[ 7 ] 手把手搭建基于 Nuxt.js SSR 的网站 如何编写 Express 后端 API","text":"经过前面教程的学习，我们已经搭建了基本的页面，现在我们来了解如何编写后端的 API。打开 server/index.js 文件，可以看到这是一个 Express 程序，加载了 Nuxt.js 的中间件，实现了服务端渲染。我们需要添加自己的路由文件，实现 API。这里建议 API 的路径前缀设置为 api，便于区分前后端路由。 新建接口在 server 文件夹下建立 routes 文件夹，并新建 post.js 文件。 123server└── routes └── post.js post.js 文件的内容如下，这里写了一个简单的接口作为示范 1234567891011121314const express = require('express')const router = express.Router()router.get('/list', (req, res) =&gt; { res.json({ result: [ { title: 'a' }, { title: 'b' }, { title: 'c' } ] })})module.exports = router; 修改 server/index.js 文件 123456789101112131415161718192021222324252627282930313233343536373839const express = require('express')const consola = require('consola')const { Nuxt, Builder } = require('nuxt')const app = express()// Import and Set Nuxt.js optionsconst config = require('../nuxt.config.js')config.dev = process.env.NODE_ENV !== 'production'/******* 引用路由文件 *******/const postRouter = require('./routes/post')async function start () { // Init Nuxt.js const nuxt = new Nuxt(config) const { host, port } = nuxt.options.server await nuxt.ready() // Build only in dev mode if (config.dev) { const builder = new Builder(nuxt) await builder.build() } /******* 加载自定义路由 *******/ app.use('/api/post', postRouter) // Give nuxt middleware to express app.use(nuxt.render) // Listen the server app.listen(port, host) consola.ready({ message: `Server listening on http://${host}:${port}`, badge: true })}start() 修改完成了，可以访问 http://localhost:3000/api/post/list 查看结果，可以看到接口返回的 JSON 数据已经展示在浏览器里了。 现在将接口数据引入前端页面，打开 pages/index.vue 文件，修改如下内容，完成了尝试打开首页，发现已经被正确渲染到页面了。 12345678async asyncData ({ $http }) { // 修改 url 为本地的 API const url = 'http://localhost:3000/api/post/list' const response = await $http.$get(url) return { postList: response.result }} 慢着，这里的请求地址似乎不太对结束了吗？显然这里是有问题的。作为一个既可能在服务端运行也可能在客户端运行的方法，asyncData 方法直接访问 localhost 是不合适的，假设在客户端运行的话，去哪里找这个 localhost 呢，用户并不会在本地运行一个服务端。 修改 pages/index.vue 文件 12345678910export default { async asyncData ({ $http }) { // 注意这里的相对路径不能以 / 开头 const url = 'api/post/list' const response = await $http.$get(url) return { postList: response.result } }} 修改 pages/about.vue 文件 123456789&lt;template&gt; &lt;div&gt; about &lt;!-- 增加链接 --&gt; &lt;nuxt-link to=\"/\"&gt; 回首页 &lt;/nuxt-link&gt; &lt;/div&gt;&lt;/template&gt; 从局域网访问可以用其他设备访问页面，但是由于之前没有设置服务器地址，所以要修改 nuxt.config.js 文件，增加 server 属性，之后可以从任意局域网内的设备对本地 IP 进行访问了。 1234server: { port: 3000, // default: 3000 host: '0.0.0.0' // default: localhost} 验证异步请求修改完成后，通过其他设备访问 http://localhost:3000，可以看到首页渲染正常。 我们跳转到 about 页，再点击”回首页”，可以发现请求失败。通过观察开发者工具的 Network -&gt; XHR，可以发现浏览器的异步请求访问了 localhost 开头的 URL，这肯定是错误的。 这时候我们需要在 nuxt.config.js 文件中增加如下配置。 123http: { browserBaseURL: '/'} 修改完成后，刷新 http://localhost:3000/about，通过点击”回首页”来返回首页，可以在开发者工具的 XHR 里面看到执行了首页的异步请求。","link":"/front-end/nuxtjs%E6%95%99%E7%A8%8B/7-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8E-Nuxt-js-SSR-%E7%9A%84%E7%BD%91%E7%AB%99-%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99-Express-%E5%90%8E%E7%AB%AF-API/"},{"title":"[ 6 ] 手把手搭建基于 Nuxt.js SSR 的网站 如何加载 UI 库","text":"为了更好地演示如何加载 UI 样式库，本文选择了 buefy 进行说明。buefy 是一种基于 bulma 的 Vue 组件库，外观整洁且轻量，便于自己定制样式。 安装 buefy 首先安装包 1yarn add buefy 编写加载组件的插件代码创建 buefy.js 文件 12plugins├── buefy.js 修改 buefy.js 文件代码，引入所有组件 1234567import Vue from 'vue'import Buefy from 'buefy'// 对于不需要覆盖官方默认样式的情况，这样引入CSS就可以了import 'buefy/dist/buefy.css'// 引入所有组件Vue.use(Buefy) 修改 nuxt.config.js，对 buefy 进行加载 123plugins: [ { src: '~/plugins/buefy.js' }] 修改首页 index.vue 代码在顶层的 div 上增加了 container 样式，内部增加了 box 样式。完成后刷新页面看下结果，可以观察到页面内容增加了一个外边框。 12345678910111213141516171819&lt;template&gt; &lt;!-- 修改这里 --&gt; &lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;nuxt-link to=\"/about\"&gt; About &lt;/nuxt-link&gt; &lt;div&gt; &lt;div v-for=\"post in postList\" :key=\"post.id\" &gt; {{ post.title }} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 按需引入组件 修改 buefy.js 文件代码 12345678910111213141516import Vue from 'vue'import 'buefy/dist/buefy.css'import { Loading, Toast, Dialog, Input, Navbar, Table, Carousel, Icon, Button, Tooltip, Tag, Pagination } from 'buefy'Vue.use(Loading)Vue.use(Toast)Vue.use(Dialog)Vue.use(Input)Vue.use(Navbar)Vue.use(Table)Vue.use(Carousel)Vue.use(Icon)Vue.use(Button)Vue.use(Tooltip)Vue.use(Tag)Vue.use(Pagination) 修改首页 index.vue 代码，增加一个 buefy 的按钮组件 1234567891011121314151617181920&lt;template&gt; &lt;div class=\"container\"&gt; &lt;div class=\"box\"&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;nuxt-link to=\"/about\"&gt; About &lt;/nuxt-link&gt; &lt;!-- 修改这里 --&gt; &lt;b-button&gt;测试按钮&lt;/b-button&gt; &lt;div&gt; &lt;div v-for=\"post in postList\" :key=\"post.id\" &gt; {{ post.title }} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;","link":"/front-end/nuxtjs%E6%95%99%E7%A8%8B/6-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8E-Nuxt-js-SSR-%E7%9A%84%E7%BD%91%E7%AB%99-%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BD-UI-%E5%BA%93/"},{"title":"[ 5 ] 手把手搭建基于 Nuxt.js SSR 的网站 如何创建前端路由","text":"前文已经实现了简单的 SSR 网站，本节将介绍如何实现前端路由。 最基本的路由在 pages 文件夹下创建 about.vue 文件 12345678910111213&lt;template&gt; &lt;div&gt; about &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 修改 pages/index.vue 文件的模版 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;nuxt-link to=\"/about\"&gt; About &lt;/nuxt-link&gt; &lt;div&gt; &lt;div v-for=\"post in postList\" :key=\"post.id\" &gt; {{ post.title }} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 这里采用了 nuxt-link 标签包裹链接，nuxt-link 是 vue-router 的包装，基本是一样的。重新刷新网页，可以看到 About 上具有链接，点击即可跳转到新的网页 http://localhost:3000/about。 动态路由动态路径在 pages 文件夹下建立 _dynamicname 文件夹，文件夹结构如下所示 1234./pages├── _dynamicname│ ├── index.vue│ └── other.vue _dynamicname 文件夹下的 index.vue 文件内容为 12345&lt;template&gt; &lt;div&gt; 动态路由首页 &lt;/div&gt;&lt;/template&gt; _dynamicname 文件夹下的 other.vue 文件内容为 1234567891011121314&lt;template&gt; &lt;div&gt; 动态路由 其他页 &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { asyncData (ctx) { // eslint-disable-next-line no-console console.log(ctx.route.params.dynamicname) }}&lt;/script&gt; 在 Nuxt.js 中，pages 文件夹下的路径与前端路由直接相关。其中带有下划线 _ 开头的文件夹或者文件都表示是一个变量，表现在地址上就是这一块是允许变化的。 上面的文件创建完成后，我们可以分别访问 http://localhost:3000/test 和 http://localhost:3000/test/other 进行查看，注意到其中的 test 即为路由变量 _dynamicname 的值。在访问 http://localhost:3000/test/other 的时候可以查看终端的打印结果，可以看到 test 的输出。 动态参数如何创建带有对象 ID 的路由呢？先创建 post 文件夹，同时在其中创建 _id.vue 文件 123./pages└── post └── _id.vue _id.vue 文件内容为 12345678910111213&lt;template&gt; &lt;div&gt; post: {{ id }} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { asyncData ({ params }) { return { id: params.id } }}&lt;/script&gt; 访问 http://localhost:3000/post/3，可以看到页面输出 post: 3。URL 中的3即映射到了 params 参数的 id 属性。 嵌套路由上面的动态参数路由，在通常情况下，可以满足我们对于实现对象实例页面的需要，但是当我们需要对子路由包裹一层父级界面的话，我们需要做下面的操作创建 users.vue 文件和 users 文件夹，包括里面的 _id.vue 文件和 index.vue 文件 12345./pages├── users│ ├── _id.vue│ └── index.vue└── users.vue users.vue 文件内容为 123456&lt;template&gt; &lt;div&gt; &lt;h1&gt;PARENT&lt;/h1&gt; &lt;nuxt-child /&gt; &lt;/div&gt;&lt;/template&gt; _id.vue 文件内容为 12345678910111213&lt;template&gt; &lt;div&gt; user id: {{ id }} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { asyncData ({ params }) { return { id: params.id } }}&lt;/script&gt; index.vue 文件内容为 12345&lt;template&gt; &lt;div&gt; users 首页 &lt;/div&gt;&lt;/template&gt; 访问 http://localhost:3000/users 页面，我们可以看到页面最上方有一个 PARENT，作为父级 UI，会包裹下面的所有子路由。里层则是上述的 index.vue 文件内容。访问 http://localhost:3000/users/2 页面，则发现里层内容变成了 user id: 2。 动态嵌套路由上面的例子可能还不够复杂，下面来演示动态嵌套路由的做法，构建如 http://localhost:3000/{路由变量}/{路由变量}/{变量} 的路由。首先创建如下所示结构的文件 1234567./pages├── _dynamicnested│ ├── _subCategory│ │ ├── _id.vue│ │ └── index.vue│ └── _subCategory.vue├── _dynamicnested.vue _dynamicnested.vue 文件内容如下，dynamicnested 被自动映射到 route.params 下的属性 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;h1&gt;_dynamicnested param: {{ dynamicNestedName }}&lt;/h1&gt; &lt;nuxt-child/&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { asyncData ({ route }) { return { dynamicNestedName: route.params.dynamicnested } }}&lt;/script&gt; _subCategory.vue 文件内容为，同样，这里的 subCategory 也被映射到了 route.params 的属性 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;h1&gt;_subCategory.vue param: {{ subDynamicName }}&lt;/h1&gt; &lt;nuxt-child /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { asyncData ({ route }) { return { subDynamicName: route.params.subCategory } }}&lt;/script&gt; index.vue 文件内容为 12345&lt;template&gt; &lt;div&gt; &lt;h3&gt;首页&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt; _id.vue 文件内容如下，这里的 id 因为不属于路由的内容，所以被映射到 params 的属性 12345678910111213&lt;template&gt; &lt;div&gt; _id {{ id }} &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { asyncData ({ params }) { return { id: params.id } }}&lt;/script&gt; 访问 http://localhost:3000/dynamicparent/subdynamic 可以看到如下所示，可以看到，URL 中的 dynamicparent 成为了 dynamicnested 属性的值，而 subdynamic 成为了 subCategory 属性的值 访问 http://localhost:3000/dynamicparent/subdynamic/3 结果如下 参考官方路由文档","link":"/front-end/nuxtjs%E6%95%99%E7%A8%8B/5-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8E-Nuxt-js-SSR-%E7%9A%84%E7%BD%91%E7%AB%99-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"},{"title":"[ 4 ] 手把手搭建基于 Nuxt.js SSR 的网站 创建自己的首页","text":"本节将详细描述如何编写前后端代码 安装 @nuxt/http 模块 首先进行安装，@nuxt/http 是官方网站所使用的请求模块，基于 ky 模块 1yarn add @nuxt/http 配置 nuxt.config.js 123modules: [ '@nuxt/http'] 编写代码把 pages/index.vue 的内容修改为如下代码，运行 yarn dev 查看结果 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;h2&gt;标题1&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { asyncData (context) { console.dir(context) }}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 可以注意到，以上代码包含了一个 Vue 中没有的方法 asyncData，这是 Nuxt 特有的方法，用来在服务端和客户端执行网络请求代码。 我们发现，这里的日志打印到了本地的终端里，而不是浏览器的 Console，这是因为当前页面在浏览器中输入网址打开后，这里的 asyncData 方法是在服务端执行的。 观察打印的结果，我们可以看到，这里的 context 包含了 isDev、error、env、req、res、route、params、query等属性，在编写代码时会经常用到。 下面我们来修改页面代码，访问网络上的公用 API 来测试一下。 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;h2&gt;标题1&lt;/h2&gt; &lt;div&gt; &lt;div v-for=\"post in postList\" :key=\"post.id\" &gt; {{ post.title }} &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { async asyncData (context) { // async asyncData ({ $http }) { // $http 可以利用 ES6 的 Object Destructing，在参数里进行解包获取 const url = 'http://jsonplaceholder.typicode.com/posts' // const response = await $http.$get(url) const response = await context.$http.$get(url) return { // 这里的 postList 会被融合到 this.data 中 postList: response } }}&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 结果如图所示，此时已经完成了最基本的 SSR 网站。","link":"/front-end/nuxtjs%E6%95%99%E7%A8%8B/4-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8E-Nuxt-js-SSR-%E7%9A%84%E7%BD%91%E7%AB%99-%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E9%A6%96%E9%A1%B5/"},{"title":"如何缓解黑苹果出现色彩断层(color banding)问题","text":"我的配置：显卡为蓝宝石RX570 4G显示器是AOC U2790PQU 解决方案安装黑苹果之后，系统信息里显示器显示为30bit色彩，但是safari的毛玻璃效果下看桌面会有色彩断层现象，查询到色彩断层在英文里似乎表述为color banding，就此进行google。查到这样一个解决方案 下载SwitchResX 启动后在顶栏图标菜单下选择Millions of Colors，此时系统信息的显卡一栏里应该是Framebuffer Depth: 24-Bit Color (ARGB8888) 经过对显示器信息的查询，支持10bit色彩，不知道为什么在mac下不支持了，暂时没有解决这个疑惑。 参考：相关讨论 The steps are incredibly simple without any technical skill.Open HackintoolSwitch to the Tools tab and press Disable Gatekeeper and mount the disk in read/write mode (for macOS Catalina and later only)Switch to the Display tab and just export without changing anythingAs Hackintool has generated 3 files and 1 folder to Desktop, just drag the folder DisplayVendorID-xxxx to /System/Library/Displays/Contents/Resources/OverridesRestart","link":"/hardware/%E5%A6%82%E4%BD%95%E7%BC%93%E8%A7%A3%E9%BB%91%E8%8B%B9%E6%9E%9C%E5%87%BA%E7%8E%B0%E8%89%B2%E5%BD%A9%E6%96%AD%E5%B1%82-color-banding-%E9%97%AE%E9%A2%98/"},{"title":"[ 3 ] 手把手搭建基于 Nuxt.js SSR 的网站 认识Nuxt.js工程的目录结构和配置","text":"目录结构打开终端，cd 到工程根目录，运行 tree 命令查看目录结构 1tree -I \"node_modules\" 结果如下 123456789101112131415161718192021222324252627.├── README.md├── assets # 程序中需要参加编译的资源，比如SCSS，Less│ └── README.md├── components # Vue组件│ ├── Logo.vue│ └── README.md├── layouts # Nuxt.js 中用于全局布局的模版，一般不用管│ ├── README.md│ └── default.vue├── middleware # 中间件，用于在页面渲染前运行代码，可以判断在服务端还是客户端运行 https://nuxtjs.org/guide/routing/#middleware│ └── README.md├── nuxt.config.js # Nuxt.js 最最最重要的配置文件├── package.json├── pages # 工程的所有页面，基于该文件夹下的目录结构自动生成前端路由│ ├── README.md│ └── index.vue├── plugins # 插件，用于载入部分包│ └── README.md├── server # 服务端代码│ └── index.js├── static # 静态文件，该文件在网站运行过程中，可以在根目录下访问│ ├── README.md│ └── favicon.ico├── store # Vuex│ └── README.md└── yarn.lock nuxt.config.js 配置文件以下是默认的文件内容，下面在文件中注释了这些配置的作用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455module.exports = { mode: 'universal', /* ** Headers of the page */ head: { // 可以在这里修改全站页面的 head 信息 title: process.env.npm_package_name || '', meta: [ { charset: 'utf-8' }, { name: 'viewport', content: 'width=device-width, initial-scale=1' }, { hid: 'description', name: 'description', content: process.env.npm_package_description || '' } ], link: [ { rel: 'icon', type: 'image/x-icon', href: '/favicon.ico' } ] }, /* ** Customize the progress-bar color */ loading: { color: '#fff' }, // 页面加载进度条的颜色设置 /* ** Global CSS */ css: [ // 可以用来加载CSS/SCSS文件 ], /* ** Plugins to load before mounting the App */ plugins: [ // 加载自定义插件 ], /* ** Nuxt.js dev-modules */ buildModules: [ // 开发时使用的模块 // Doc: https://github.com/nuxt-community/eslint-module '@nuxtjs/eslint-module' ], /* ** Nuxt.js modules */ modules: [ // 载入第三方模块 // Doc: https://github.com/nuxt-community/dotenv-module '@nuxtjs/dotenv' ], /* ** Build configuration */ build: { // 编译配置 /* ** You can extend webpack config here */ extend (config, ctx) { } }} 注意，修改 nuxt.config.js 文件之后，需要重启服务也就是 Ctrl + C 关闭服务之后重新启动 yarn dev 常见配置问题（以下均为 nuxt.config.js 文件的根节点） 如何全局引入外部 script 文件？ 12345head: { script: [ { src: 'https://example.com' } ]} 如何自定义链接的 Active 样式？ 123router: { linkActiveClass: 'is-active'} 如何自定义加载进度条的样式？ 12345loading: { color: '#123456', height: '5px', throttle: 0} 如何载入自定义 CSS/SCSS 样式文件？ 123css: [ '@/assets/css/custom.scss',] 如何定义样式 SCSS 文件的全局变量？ 安装 @nuxtjs/style-resources1yarn add @nuxtjs/style-resources 引入模块123modules: [ '@nuxtjs/style-resources'] 在工程的根目录下的 assets 文件夹创建 /css/variable.scss 文件 写入内容，如1$hover-color: #123456; 修改 nuxt.config.js 文件12345styleResources: { scss: [ '@/assets/css/variable.scss' ]} 此时在 Vue 文件的样式内即可直接引用这个变量 使用 nuxt/http进行异步请求，但是部署后发现前端请求(AsyncData)访问的主机是 localhost？ 修改 http 模块的配置，设置前端请求的基础 URL123http: { browserBaseURL: '/'} 如何修改编译的输出目录？ 1buildDir: 'nuxt-dist' // 默认是 .nuxt 如何定义 CDN 服务器的地址？ 将编译输出目录下的 /dist/client 文件夹上传 CDN，假设把client文件夹重命名为 _nuxt 修改配置文件123build: { publicPath: IS_PROD ? CDN_PREFIX + '/_nuxt/' : '/_nuxt/'}","link":"/front-end/nuxtjs%E6%95%99%E7%A8%8B/3-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8E-Nuxt-js-SSR-%E7%9A%84%E7%BD%91%E7%AB%99-%E8%AE%A4%E8%AF%86Nuxt-js%E5%B7%A5%E7%A8%8B%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%92%8C%E9%85%8D%E7%BD%AE/"},{"title":"[ 2 ] 手把手搭建基于 Nuxt.js SSR 的网站 如何搭建 Nuxt.js 的开发环境","text":"代码 github 地址https://github.com/uniblackfire/nuxtjstourial 需要的工具 Yarn后续所有安装操作都基于 Yarn 进行，这是一种新的包管理工具。 开发工具 Visual Studio Code Webstrom 创建项目在终端执行下面的命令即可开始创建新项目 1yarn create nuxt-app &lt;项目名&gt; 终端会有如下提示 包管理器，选择 Yarn UI 框架，根据自己的喜好进行选择，碧野选择了 None（如果不选择也可以在后续添加，不带有 Vue 组件的纯UI框架可以通过引入外部网站托管的文件来实现加载，减少对本地网络资源的消耗同时提高加载速度） 服务端框架，选择了 Express，因为该框架比较成熟，社区关于它的经验也比较丰富 Nuxt.js 模块，只选择了 DotEnv，用于加载工程根目录下的 .env 环境配置文件 linting 工具选择了 EsLint 测试框架没有选择 渲染模式选择通用，进行 SSR 开发工具没有选择 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849create-nuxt-app v2.14.0✨ Generating Nuxt.js project in nuxtdemo? Project name nuxtdemo? Project description My superior Nuxt.js project? Author name bitzx? Choose the package manager (Use arrow keys)❯ Yarn Npm ? Choose UI framework (Use arrow keys)❯ None Ant Design Vue Bootstrap Vue Buefy Bulma Element Framevuerk iView Tachyons Tailwind CSS Vuesax Vuetify.js? Choose custom server framework None (Recommended) AdonisJs ❯ Express Fastify Feathers hapi Koa Micro ? Choose Nuxt.js modules ◯ Axios ◯ Progressive Web App (PWA) Support❯◉ DotEnv? Choose linting tools (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)❯◉ ESLint ◯ Prettier ◯ Lint staged files ◯ StyleLint? Choose test framework (Use arrow keys)❯ None Jest AVA ? Choose rendering mode (Use arrow keys)❯ Universal (SSR) Single Page App? Choose development tools (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)❯◯ jsconfig.json (Recommended for VS Code) ◯ Semantic Pull Requests 配置完成后，会对上面选择的包进行安装。 修改 package.json修改完成请执行 yarn 进行安装 1234567\"dependencies\": { \"@nuxt/http\": \"^0.3.9\", \"@nuxtjs/dotenv\": \"^1.4.0\", \"cross-env\": \"^5.2.0\", \"express\": \"^4.17.1\", \"nuxt\": \"^2.11.0\"} 测试运行执行以下命令运行新创建的工程 12cd &lt;项目名&gt;yarn dev 提交初始代码12git add .git commit -m 'init' 参考Nuxt.js官方网站源代码 1git clone git@github.com:nuxt/nuxtjs.org.git","link":"/front-end/nuxtjs%E6%95%99%E7%A8%8B/2-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8E-Nuxt-js-SSR-%E7%9A%84%E7%BD%91%E7%AB%99-%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA-Nuxt-js-%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"},{"title":"[ 1 ] 手把手搭建基于 Nuxt.js SSR 的网站 为什么需要 Nuxt.js","text":"单页应用为什么不利于SEO随着前端技术发展，越来越多的前端开发转向了单页应用，也就是 Vue、React 这些框架。但是这些框架有一个非常大的问题，就是内容是靠 JavaScript 渲染的，服务器在初始阶段发送到浏览器的 HTML 并不包含内容。这就导致一个问题，如果搜索引擎不支持执行 JS 代码的话，他在爬取这个页面的时候就看不到任何具体内容，进而影响搜索引擎的收录和网站排名。 Server Side Render 是什么直接翻译就是“服务端渲染”，把原先在浏览器端由 JS 完成的内容渲染工作放到服务端进行，这样在浏览器初次访问的时候就可以直接获取到渲染完成的 HTML 文件。有朋友要说，我们完全可以回到服务端语言直接渲染模版的工作方式，这当然是可以的，但是这样又重新把前后端的工作交叉在一起，不便于前后端分工和对现有前端工程技术的使用。 为什么选择 Nuxt.js从 Vue 的官网可以了解到，完全可以自己搭建一套基于 Vue 的 SSR 环境，但是由于有了 Nuxt.js 的出现，我们可以把这些流程大大简化。Nuxt.js 提供了一整套 SSR 需要的环境和配置，同时有良好的社区支持，我们只需要在它的框架下就可以轻松实现 SSR。 为什么要写这个教程因为个人需要搭建网站，选择了这个技术之后发现相关中文文档不够全面，且官网中文文档滞后于英文文档，碰到的问题也几乎都是自己摸索或者从英文网站得到答案。希望可以记录下自己遇到的问题，方便后来者。 在这里可以学到什么 搭建船新的基于 Nuxt.js 的网站 了解其中的各种坑和技巧 学习后续教程需要了解的知识 VueNuxt.js 基于 Vue 开发，点此查看 Vue 的官方教程","link":"/front-end/nuxtjs%E6%95%99%E7%A8%8B/1-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%90%AD%E5%BB%BA%E5%9F%BA%E4%BA%8E-Nuxt-js-SSR-%E7%9A%84%E7%BD%91%E7%AB%99/"},{"title":"2019年12月黑苹果折腾笔记及经验分享","text":"我的配置 CPU: Intel i5 4590 主板: 华硕B85 Pro Gamer 显卡: 蓝宝石 RX570 4G 折腾方法 下载黑果小兵的10.15.2的镜像 balenaEthcer写入镜像到一个优盘 开机设置BIOS里为优盘启动 安装macos 进入macos系统后，打开clover configurator，打开左侧的Mount EFI，查看右侧的Efi Partitions，分别Mount Partition硬盘和启动优盘，然后分别Open Partition，把启动优盘里的所有文件拷贝进硬盘里，这就实现了硬盘启动 重启电脑，关闭BIOS里的串行设备！（解决了睡眠唤醒后黑屏的问题！！！） 设置启动顺序，为硬盘上的UEFI开头的启动项！ 打开clover configurator，挂载本地硬盘，打开EFI文件夹，右键点击config.plist，选择clover configurator打开，选择左侧的SMBIOS，选择右侧的“上下”箭头的图标，选择iMacPro1,1的机型（开启独立显卡的硬件加速） 参考 i5 4590+ASUS B85 Pro Gamer+RX570黑苹果10.14.3的EFI分享 黑苹果安装笔记","link":"/hardware/2019%E5%B9%B412%E6%9C%88%E9%BB%91%E8%8B%B9%E6%9E%9C%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0%E5%8F%8A%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"},{"title":"JS Date函数比较","text":"","link":"/front-end/JS-Date%E5%87%BD%E6%95%B0%E6%AF%94%E8%BE%83/"},{"title":"Vue基础","text":"由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，这样写不会触发更新： 1vm.items[indexOfItem] = newValue 正确的方法： 123456// Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue)// 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：vm.$set(vm.items, indexOfItem, newValue) 当你修改数组的长度时，这样写不会触发更新： 1vm.items.length = newLength 正确的方法： 1vm.items.splice(newLength) 不推荐同时使用 v-if 和 v-for。当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级。 在使用 v-for 时，尽量提供 key。2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。 选择框，如果 v-model 表达式的初始值未能匹配任何选项，&lt;select&gt; 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项(&lt;option disabled value=&quot;&quot;&gt;请选择&lt;/option&gt;)。 如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符。 Vue 提供了一个 $listeners 属性，它是一个对象，里面包含了作用在这个组件上的所有监听器。有了这个 $listeners 属性，你就可以配合 v-on=&quot;$listeners&quot; 将所有的事件监听器指向这个组件的某个特定的子元素。 .sync 修饰符 插槽 在向具名插槽提供内容的时候，我们可以在一个 &lt;template&gt; 元素上使用 v-slot 指令，并以 v-slot 的参数的形式提供其名称 混入 mixin 同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。 $nextTick 为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。 Vuex mapState 获取状态 mapGetters 将 store 中的 getter 映射到局部计算属性 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。 1store.commit('increment') mutation 必须是同步函数 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store） Action 类似于 mutation，不同在于： Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。1store.dispatch('increment') mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store） 当网站足够大时，一个状态树下，根的部分字段繁多，解决这个问题就要模块化 vuex 默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。 如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。 完整的闭环是 store.dispatch(‘action’) -&gt; action -&gt; commit -&gt; mutation -&gt; getter -&gt; computed 建议是不论多简单的流程都跑完整个闭环，形成代码的统一，方便后期管理，在组件里只允许出现 dispatch 和 mapGetters，其余的流程都在名为 store 的 vuex 文件夹里进行 可以打印this.$store查看store里的数据 如果store的模块里没有加namespaced，则这个模块的数据是全局的，不需要加路径来引用 v-show，v-if 用哪个？ 权限问题，只要涉及到权限相关的展示无疑要用 v-if 在没有权限限制下根据用户点击的频次选择，频繁切换的使用 v-show，不频繁切换的使用 v-if 尽量保持每个组件 export default {} 内的方法顺序一致 在 webpack 里有个 externals，可以忽略不需要打包的库123456externals: { 'vue': 'Vue', 'vue-router': 'VueRouter', 'vuex': 'Vuex', 'axios': 'axios'} nextTick https://juejin.im/post/5a6fdb846fb9a01cc0268618","link":"/front-end/Vue%E5%9F%BA%E7%A1%80/"},{"title":"利用 charles 和 switchyomega 对被墙网站进行抓包","text":"为了对某国外被墙的网站进行抓包，在网上搜索之后，发现很多说要关闭VPN才能用Charles抓包，明显这是不可能的。于是想到把Charles作为代理服务器，让他连接VPN，然后浏览器把Charles作为代理，即可完成抓包。即：VPN -&gt; Charles -&gt; 浏览器首先在Charles中设置External Proxy Setting，设置为VPN软件在系统内设置的代理，此时Charles已经翻墙。 由于浏览器默认使用系统的代理，所以打开预先在Chrome浏览器内安装的SwitchyOmega，增加如图的配置，即可让浏览器把Charles作为代理，并切换到该配置， 参考：抓包神器之Charles，常用功能都在这里了","link":"/others/capture-banned-website-with-charles-and-switchyomega/"},{"title":"用 CSS 画圆角三角形","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;style type=\"text/css\"&gt; .line { width: 20px; height: 200px; background: red; position: relative; border-radius: 900px; } .line:after, .line:before { position: absolute; content: ''; width: 20px; background: red; border-radius: 900px; height: 200px; } .line:after { transform: rotate(-60deg); top: -44px; right: -81px; } .line:before { transform: rotate(60deg); top: 46px; right: -80px; } .outer { width: 500px; height: 500px; display: flex; justify-content: center; align-items: center; background: black; } .inner { display: inline-block; width: 0; height: 0; border-style: solid; border-width: 80px 0 90px 150px; position: absolute; border-color: transparent transparent transparent red; top: 10px; right: -150px; }&lt;/style&gt;&lt;body&gt;&lt;div class=\"outer\"&gt; &lt;div class=\"line\"&gt; &lt;span class='inner'&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","link":"/front-end/corners/"},{"title":"canvas 的外层 Div 为 overflow:hidden 时仍然可见","text":"参考链接answer from stackoverflow","link":"/front-end/canvas-still-visible-when-outer-div-is-set-to-overflow-hidden/"},{"title":"chrome dev tools 的小技巧","text":"看了google官方关于chrome dev tools调试的介绍。发现了两个很好用的功能： restart frame blackbox script，可以避免单步到库文件","link":"/front-end/tricks-in-chrome-dev-tools/"},{"title":"如何用 charles 修改拦截请求的返回值","text":"起因网易云音乐在朋友圈刷了一波推广活动，一进去要输入名字，但是我玩法比较怪，输入的是一些名人的名字，结果被提示“不是你的名字”。于是，把网址放到chrome里，打开dev tool查看，发现提交到服务器进行了验证，而且只要命中名人名字中的两个字，就会被提示报错，你们的算法还挺细致的，哈哈。 比较了一下前端请求验证名字的请求后，服务器返回的验证结果，发现只有最后一个字段不同，猜测前端判断了这个结果，于是想到拦截修改服务器的返回结果，骗过前端程序。 尝试了不同的方法map local 右键点击验证请求，选择save response，保存响应文件 按下⌥⌘L打开Map Local Setting对话框，并增加新的mapping 再次尝试通过前端发送请求，确实修改了响应结果，但是由于保存的响应文件只有body的内容，没有header的内容，在这里报了一个跨域的错误，因此这个方法失败了。 rewrite 按下⌥⌘L打开Rewrite Settings对话框，直接输入需要重写的内容 此时请求之后返回的结果只修改了body部分，别的部分都是原样输出，已经通过了前端程序的验证。 breakpoint 右键点击请求，选择breakpoint，下断点 再次请求，修改响应结果 可以在chrome里看到此时已经是刚刚修改后的响应结果了 碰到的问题 有可能突然抓不到包，可以尝试⇧⌘P关闭macOS proxy，然后再次打开。","link":"/others/how-to-modify-server-response-with-charles/"},{"title":"管理学习进度","text":"为什么想到这个工作以来，为了提升个人能力，一直不断松懈学习。之前看到一篇技术文章，令我感到反思的不是文章的内容，而是作者的学习方法，所以做了这样的思维导图： 需求： 进度规划 每日打卡 提醒 之前的做法 打印日历进行记录（缺点是需要打印，且没有提醒） 利用 numbers 表格记录每日学习内容，完成之后便划掉（需要另外打开软件，无提醒，不方便修改） 利用 wunderlist 记录（无进度） 考虑结合 google cal 进行管理好处 多平台同步，web、mac、iphone等都可以看到 不需要另外的软件 可以利用 week calendar 进行快速标记完成，高亮等操作 步骤 在 google cal 上新建一个日历，以和其他日历内容区隔 下面是 week calendar 的主界面，可以看到我已经配置了一些日历内容 打开右上角的设置 点击工具菜单，可以配置快捷操作，我在这里设置了两个，一个是快速标记完成✅，另外一个是高亮 配置 mac 日历，尝试同步 新增事件时，可以设置每日循环和到期日，这样子可以每天进行打卡","link":"/others/%E7%AE%A1%E7%90%86%E5%AD%A6%E4%B9%A0%E8%BF%9B%E5%BA%A6/"},{"title":"JavaScript 中 require 和 import 的区别","text":"require object is just a shallow copy of module exportstest code as below: 12345678910111213141516171819202122// main.jsvar a = require('./mod')setInterval(() =&gt; { console.log('in main', a.aaa) console.log('in main', a.x) console.log('======');}, 500);// mod.jslet aaa = {a: 3, b: {xx: 1}}let x = 1setInterval(() =&gt; { aaa.a++; aaa.b.xx += 1; x++; console.log('in mod', aaa) console.log('in mod', x)}, 500);module.exports = {aaa: aaa, x: x}; References require，import区别？ Module 的加载实现 Node中没搞明白require和import，你会被坑的很惨","link":"/front-end/something-about-module-in-nodejs/"},{"title":"HTML5 中 video 标签问题总结","text":"problems encounted when start play a video on iOS’s Safari and Wechat browser, it will enter fullscreen but not play in line 1&lt;video controls=\"\" playsInline webkit-playsinline=\"true\" x5-playsinline&gt;&lt;/video&gt; video duration can be achieved when durationchange event fired canplay event will not fired when video loaded on iPhone iOS 11 Safari even I add preload=&quot;auto&quot; prop, but fired on iPad iOS 10 Safari Reference 移动端 HTML5 video 视频播放优化实践 视频H5 video标签最佳实践 移动端 HTML5 video 视频播放实践 New video Policies for iOS 这几年，我在video上踩的坑 为什么要将 Chimee 设计成一个组件化框架？ 视频H5のVideo标签在微信里的坑和技巧 关于HTML5 video标签在安卓版微信浏览器内被强制全屏播放的问题 Creating a cross-browser video player Media formats for HTML audio and video HTML 5 视频/音频参考手册","link":"/front-end/play-with-html5-video-tag/"},{"title":"javascript 学习思维导图","text":"","link":"/front-end/mindmap-for-learning-javascript/"}],"tags":[{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"apple","slug":"apple","link":"/tags/apple/"},{"name":"黑苹果","slug":"黑苹果","link":"/tags/%E9%BB%91%E8%8B%B9%E6%9E%9C/"},{"name":"hackintosh","slug":"hackintosh","link":"/tags/hackintosh/"},{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"charles","slug":"charles","link":"/tags/charles/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"devtools","slug":"devtools","link":"/tags/devtools/"},{"name":"calendar","slug":"calendar","link":"/tags/calendar/"},{"name":"gtd","slug":"gtd","link":"/tags/gtd/"},{"name":"mac","slug":"mac","link":"/tags/mac/"},{"name":"iphone","slug":"iphone","link":"/tags/iphone/"},{"name":"switchyomega","slug":"switchyomega","link":"/tags/switchyomega/"},{"name":"macos","slug":"macos","link":"/tags/macos/"},{"name":"clover","slug":"clover","link":"/tags/clover/"},{"name":"nuxtjs","slug":"nuxtjs","link":"/tags/nuxtjs/"},{"name":"ssr","slug":"ssr","link":"/tags/ssr/"}],"categories":[{"name":"hardware","slug":"hardware","link":"/categories/hardware/"},{"name":"front-end","slug":"front-end","link":"/categories/front-end/"},{"name":"others","slug":"others","link":"/categories/others/"},{"name":"nuxtjs教程","slug":"front-end/nuxtjs教程","link":"/categories/front-end/nuxtjs%E6%95%99%E7%A8%8B/"}]}